/* ===== FASHION. â€” Shared Format Module ===== */
/* Price formatting, store name/flag/category lookups */
/* Reads from data/store-index.json (generated by migrate-stores.js) */

const CURRENCY_SYMBOLS = { EUR: 'â‚¬', GBP: 'Â£', USD: '$', SEK: 'kr', DKK: 'kr', NOK: 'kr' };

// Runtime store metadata â€” populated by loadStoreMetadata()
let storeMetadata = {};
let storeMetadataLoaded = false;

/**
 * Load store metadata from store-index.json.
 * Call once at app init. All store lookups work after this resolves.
 * @returns {Promise<void>}
 */
export async function loadStoreMetadata() {
  if (storeMetadataLoaded) return;
  try {
    const resp = await fetch('data/store-index.json');
    const data = await resp.json();
    if (data.stores) {
      for (const s of data.stores) {
        storeMetadata[s.slug] = {
          name: s.name,
          flag: s.flag,
          country: s.country,
          category: s.category,
          categoryIcon: s.categoryIcon
        };
      }
      storeMetadataLoaded = true;
    }
  } catch (e) {
    console.warn('Could not load store metadata:', e);
  }
}

/**
 * Format a price object into a display string.
 * @param {{ amount: number, currency: string }} priceObj
 * @returns {string} e.g. "â‚¬129.99" or ""
 */
export function formatPrice(priceObj) {
  if (!priceObj || !priceObj.amount || priceObj.amount === 0) return '';
  const sym = CURRENCY_SYMBOLS[priceObj.currency] || priceObj.currency + ' ';
  return `${sym}${priceObj.amount}`;
}

/**
 * Convert store slug to display name.
 * @param {string} slug - e.g. "end-clothing"
 * @returns {string} e.g. "END. Clothing"
 */
export function storeDisplayName(slug) {
  if (storeMetadata[slug]) return storeMetadata[slug].name;
  // Fallback: convert slug to title case
  return slug.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

/**
 * Get flag emoji for a store slug.
 * @param {string} slug
 * @returns {string} Flag emoji or default ðŸ·ï¸
 */
export function storeFlag(slug) {
  if (storeMetadata[slug]) return storeMetadata[slug].flag;
  return '\u{1F3F7}\u{FE0F}';
}

/**
 * Get country for a store slug.
 * @param {string} slug
 * @returns {string} Country name or ''
 */
export function storeCountry(slug) {
  if (storeMetadata[slug]) return storeMetadata[slug].country;
  return '';
}

/**
 * Get category for a store slug.
 * @param {string} slug
 * @returns {string} Category name or ''
 */
export function storeCategory(slug) {
  if (storeMetadata[slug]) return storeMetadata[slug].category;
  return '';
}

/**
 * Get category icon for a store slug.
 * @param {string} slug
 * @returns {string} Category icon emoji or ðŸ·ï¸
 */
export function storeCategoryIcon(slug) {
  if (storeMetadata[slug]) return storeMetadata[slug].categoryIcon;
  return '\u{1F3F7}\u{FE0F}';
}

/**
 * Check if store metadata has been loaded.
 * @returns {boolean}
 */
export function isStoreMetadataLoaded() {
  return storeMetadataLoaded;
}

/**
 * Get all loaded store entries (for iteration/filtering).
 * @returns {Object} Map of slug â†’ { name, flag, country, category, categoryIcon }
 */
export function getAllStores() {
  return { ...storeMetadata };
}

/**
 * Get the best listing from a product (lowest sale price, preferring available).
 * @param {object} product
 * @returns {object|null}
 */
export function bestListing(product) {
  if (!product.listings || product.listings.length === 0) return null;
  const available = product.listings.filter(l => l.available);
  const pool = available.length > 0 ? available : product.listings;
  return pool.reduce((best, l) =>
    (l.salePrice && l.salePrice.amount > 0 &&
     (!best.salePrice || l.salePrice.amount < best.salePrice.amount)) ? l : best
  );
}

/**
 * Aggregate all sizes across a product's listings.
 * @param {object} product
 * @returns {string[]}
 */
export function allSizes(product) {
  if (!product.listings) return [];
  const s = new Set();
  product.listings.forEach(l => (l.sizes || []).forEach(sz => s.add(sz)));
  return [...s];
}
